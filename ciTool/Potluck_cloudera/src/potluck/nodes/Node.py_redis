"""
.. moduleauthor:: Sandeep Nanda <mail: sandeep.nanda@guavus.com> <skype: snanda85>

This module provides the base methods to be used with node handles

Most of the methods are used internally by the framework.
View Source to take a look at all the methods.
"""

import pexpect
import sys
import re
import time
import commands
import os
import datetime
from potluck.logging import logger
from potluck.nodes import CLI_MODES
from potluck import utils
from settings import REMOTE_DIR, ROOT_DIR
import threading
globalCount = 0
ansi_escape_chars = re.compile(r'(?m)((\x1b[^m\r\n]*m)|(\x1b[^\r\n]+\x1b[=>]))')
def remove_special(s):
    """Removes special characters (mostly ANSI) seen in command outputs, from gingko platform onwards"""
    return ansi_escape_chars.sub('', s)
class Node(object):
    """Base class for all type of Nodes. Specific node types (like NN, DN etc.)
    are inherited from this class

    Default values associated with all nodes are:

    * Username: admin
    * Connection type: ssh
    * Connection port: 22
    """

    def __init__(self, node):
        """
        constructor to initialize various parameters IP and Port of a node. This can be overridden
        in the derived classes if the nodes use some non-default parameters
        like connection type, port number, username

        `node` should be dict with the below format::

            {
                'alias': 'UI1',
                'type': 'NameNode',
                'connection': 'ssh',
                'ip': '192.168.154.7',
                'port': '22'
                'password': 'root@123',
            }
        """
        # _session will hold the underlying pexpect session handle
        self._session = None
        self.alias = node["alias"]
        self.ip = node["ip"]
        self.password = node["password"]
        self.port = node["port"]
        self.connection_type = node["connection"]
        self.info = node    # Store the raw testbed information
        self.promptuser = r"[\r\n][^\r\n]* # "
        self.promptshell = r"\[root\@[\.a-zA-Z0-9]+ [\~]+\]\# "
	
        self.prompts = {
            "user"   : re.compile(self.promptuser),
            CLI_MODES.shell  : re.compile(self.promptshell),
        }
        self.promptmore = re.compile(r"lines \d+-\d+")
        self._mode = None
        self._mode_stack = []
        self.connect()

    def __str__(self):
        return "%s <%s>" % (self.alias, self.ip)

    def __remote_id__(self):
        """Returns the ID of the object to be used for remoting testcases"""
        return hash(self)

    def __getattr__(self, name):
        try:
            # Provides access to the members of node info dict
            return getattr(self.info, name)
        except AttributeError:
            raise AttributeError("Parameter '%s' is not present in node '%s'" % (name, self.alias))

    def connect(self):
        """Internally used by Potluck to connect to the node, by taking care of the connection type used.

        For now, only ssh connections are supported
        """
        if self.connection_type == "ssh":
            self._session = self.connectSsh()
        else:
            raise NotImplementedError("Connection type not implemented: %s" % connection_type)

    def disconnect(self):
        self._session.close()

    def isConnected(self):
        """Returns True is the node is connected, otherwise returns False"""
        if self._session is None:
            return False
        return self._session.isalive() is True

    def reconnect(self):
        current_mode = self.getMode()
        self.disconnect()
        self.connect()
        # Switch back to the mode that we were already in
        self.setMode(current_mode)



    def connectSsh(self):
        """__
        Connects to the node using ssh and returns the session handle
        """
        connect_handle = pexpect.spawn("ssh -q -o StrictHostKeyChecking=no root@%s" % self.ip)
        connect_handle.setwinsize(800,800)
        connect_handle.logfile_read = sys.stdout
        #connect_handle.logfile_send = sys.stdout
        i = 0
        ssh_newkey = r'(?i)Are you sure you want to continue connecting'
        remote_key_changed = r"REMOTE HOST IDENTIFICATION HAS CHANGED"

        perm_denied = r"(?i)Permission denied"
        while True:
            i = connect_handle.expect([ssh_newkey, 'assword:',self.promptshell,
                                        pexpect.EOF, pexpect.TIMEOUT,
                                        remote_key_changed, perm_denied])
            if i==0:
                connect_handle.sendline('yes')
                continue
            elif i==1:
                 logger.info("Password supplied")
                 connect_handle.sendline(self.password)
                 continue
	    elif i==2:
                self._mode = CLI_MODES.shell
                self._prompt = self.promptshell
                break
            elif i==3:
                logger.info("Connection closed: %s" % self)
                logger.info(connect_handle.before) # print out the result
                raise ValueError("Connection Closed: %s" % self)
            elif i==4:
                logger.warning("Timeout while waiting for connection")
                logger.info(connect_handle.before) # print out the result
                raise ValueError("Unable to establish connection %s" % self)
            elif i==5:
                logger.warn("Removing offending key from .known_hosts..")
                known_hosts_file = os.path.expanduser("~/.ssh/known_hosts")

                if "darwin" in sys.platform.lower():
                    # MAC OS
                    utils.run_cmd("sed -i 1 's/%s.*//' %s" % (self.ip, known_hosts_file))
                elif "linux" in sys.platform.lower():
                    # Linux
                    utils.run_cmd("sed -i 's/%s.*//' %s" % (self.ip, known_hosts_file))

                connect_handle = pexpect.spawn("ssh root@%s" % self.ip)
                connect_handle.setwinsize(800,800)
                connect_handle.logfile_read = sys.stdout

                continue
            elif i==6:
                logger.warning("Permission denied: %s" % self)
                logger.info(connect_handle.before) # print out the result
                raise ValueError("Permission denied: %s." % self)
        return connect_handle

    def resetStream(self, stream=None):
        # Stream should be reset everytime, otherwise cleanup action's log won't be printed in any other file
        if stream is None:
            self._session.logfile_read = sys.stdout
        else:
            self._session.logfile_read = stream

    def initShell(self):
        self.sendCmd("unalias cp ls")

    def run_cmd1(self,command,custom_expect='#'):
        self._session.sendline(command)
        i = self._session.expect([pexpect.EOF, pexpect.TIMEOUT, "logging out" ,custom_expect])
        if i == 0:
                # EOF
                logger.error("Connection closed %s" % self)
                raise ValueError("Connection Closed")
        elif i == 1:
                # TIMEOUT
                logger.error(str(self._session))
                logger.error("Time Out")
                raise ValueError("Time Out")
	elif i == 2:
		logger.info("Logged out due to inactivity. Reconnecting..")
                self.reconnect()
                self._session.sendline(cmd)
                #continue
	elif i == 3:
		logger.info("executed command successfully")
	return(self._session.before)

    def getCommandOutput(self,command,expect = "#"):
        print "Running command: " + command
        print "expect : %s" %expect
        self._session.sendline(command)
        self._session.expect(expect)
        logger.info("Running command : " + command)
        print "output is :",self._session.before
        return(self._session.before)

    def run_cmd(self,command,custom_expect = '#',timeout=30,ignoreErrors=False):
        self._session.sendline(command)

        i = self._session.expect([pexpect.EOF, pexpect.TIMEOUT, "logging out" ,self.promptmore,custom_expect],timeout=timeout)
        if i == 0:
                # EOF
                logger.error("Connection closed %s" % self)
                raise ValueError("Connection Closed")
        elif i == 1:
                # TIMEOUT
                logger.error(str(self._session))
                logger.error("Time Out")
                raise ValueError("Time Out")
        elif i == 2:
                logger.info("Logged out due to inactivity. Reconnecting..")
                self.reconnect()
                self._session.sendline(cmd)
        elif i == 3:
                # More prompt. Send Space
                self.last_output += self._session.before
                self._session.send(" ")
        elif i == 4:
                self.last_output = self._session.before
                logger.info("executed command successfully")

        self.last_output = re.sub("(?m)" + re.escape(command), "", self.last_output)
	if not ignoreErrors and re.search("\b:*(error|unable|failed|failure|unrecognized command):*\b", self.last_output, re.I):
            logger.error("Error while executing command")

        if command.startswith("hadoop"):
            self.last_output = re.sub(r"(?m)^\s*WARNING:.*$", "", self.last_output)

        # Remove some special characters seen in new platforms (gingko onwards)
        ret_val = remove_special(self.last_output)
        return ret_val.strip()


    def sendMultipleCmd(self, cmds, *args, **kwargs):
        consolidated_output = ""
        for cmd in cmds.split("\n"):
            consolidated_output += self.sendCmd(cmd, *args, **kwargs)
            consolidated_output += "\n"
        return consolidated_output


    def getMode(self):
        """Returns the current mode of the device"""
        return self._mode

    def setMode(self, targetmode):
        """Sets a mode on the device.

        The following modes are supported:

        #. enable
        #. config
        #. shell
        #. pmx
        #. mysql
        """
        self.resetStream()

        if targetmode not in self.prompts.keys():
            raise ValueError("Invalid Mode %s" % targetmode)

        initialmode = self.getMode()
        if targetmode == initialmode:
            logger.debug("In %s mode" % targetmode)
            return True

        logger.debug("Changing mode from '%s' to '%s' on %s" % (initialmode, targetmode, self))

        # Provide all permutations of mode switching
        if   targetmode == CLI_MODES.config and initialmode == CLI_MODES.enable:
            self._session.sendline("config terminal")
        elif targetmode == CLI_MODES.config and initialmode == CLI_MODES.shell:
            self._session.sendline("cli -m config")
        elif targetmode == CLI_MODES.config and initialmode == CLI_MODES.pmx:
            self._session.sendline("quit")
        elif targetmode == CLI_MODES.enable and initialmode == CLI_MODES.shell:
            self._session.sendline("cli -m enable")
        elif targetmode == CLI_MODES.enable and initialmode == CLI_MODES.config:
            self._session.sendline("exit")
        elif targetmode == CLI_MODES.shell and initialmode == CLI_MODES.enable:
            self._session.sendline("_shell")
        elif targetmode == CLI_MODES.shell and initialmode == CLI_MODES.config:
            self._session.sendline("_shell")
        elif targetmode == CLI_MODES.shell and initialmode == CLI_MODES.mysql:
            self._session.sendline("quit")
        elif targetmode == CLI_MODES.pmx:
            self.setMode(CLI_MODES.config)
            self._session.sendline("pmx")
        elif targetmode == CLI_MODES.mysql:
            self.setMode(CLI_MODES.shell)
            self._session.sendline("idbmysql")
        elif targetmode != CLI_MODES.config and initialmode == CLI_MODES.pmx:
            # Moving from pmx to other modes. Switch to config and proceed..
            self.setMode(CLI_MODES.config)
            self.setMode(targetmode)
            self._session.sendline("")  # Send empty line for guessMode to work
        elif targetmode != CLI_MODES.shell and initialmode == CLI_MODES.mysql:
            # Moving from mysql to other modes. Switch to shell and proceed..
            self.setMode(CLI_MODES.shell)
            self.setMode(targetmode)
            self._session.sendline("")  # Send empty line for guessMode to work
        else:
            raise ValueError("Invalid Mode combination. Targetmode: %s, Currentmode: %s" % (targetmode, initialmode))

        finalmode = self.guessMode()
        logger.debug("Mode changed to %s mode" % finalmode)
        if targetmode == finalmode:
            if finalmode == CLI_MODES.shell:
                self.initShell()
            return True
        else :
            # A user can be in pmx subshells. So we might need to get back a couple levels
            if finalmode == CLI_MODES.pmx and targetmode == CLI_MODES.config:
                return self.setMode(CLI_MODES.config)
            else:
                logger.warn("Unable to set '%s' mode" % targetmode)
                return False
    


    def isInCluster(self):
        """Check if the node is a part of a TM Cluster"""
        logger.debug("Checking if %s is a part of cluster" % self)
        role = self.getClusterRole()
        return role is not None and role != "DISABLED"

    def isMaster(self):
        """Check if the node is currently the master of Cloudera Cluster"""
        logger.debug("Checking if %s is Cloudera Master" % self)
        is_master = self.getClusterRole() == "MASTER"
        logger.debug("Is %s master: %s" % (self, is_master))
        return is_master
   
    def isStandby(self):
        """Check if the node is currently the standby of TM Cluster"""
        logger.debug("Checking if %s is TM Standby" % self)
        is_standby = self.getClusterRole() == "STANDBY"
        logger.debug("Is %s standby: %s" % (self, is_standby))
        return is_standby


        output = self.sendCmd("image fetch %s" % imageurl, 3600)
        for err in image_fetch_errors:
            if re.search(err, output, re.I):
                logger.error("Image fetch failed")
                return False


    def listDirectory(self, directory):
        """Returns the list of contents of a directory

        :param directory: The path of the directory to be listed
        :returns: List of dict in the format {"filename" : filename, "type" : filetype}
        """
        self.pushMode(CLI_MODES.shell)
        output = self.sendCmd("ls -F %s" % directory)
        self.popMode()
        if "No such file" in output:
            return []
        output_list = []
        for filename in output.split():
            filename, filetype = self._extractFileDetails(filename)
            output_list.append({
                "filename" : filename,
                "type" : filetype,
            })
        return output_list

    def createDirectory(self, directory):
        """Creates a directory on the machine

        :param directory: The path of the directory to be created
        """
        self.pushMode(CLI_MODES.shell)
        output = self.sendCmd("mkdir -p %s" % directory)
        self.popMode()
        return output

    def removePath(self, path):
        """Removes a file/directory from the machine

        :param path: The path of the file/directory to be removed

        .. warning::

            This method will forcefully remove (`rm -rf`) the path. Be Careful while calling this method.
        """
        self.pushMode(CLI_MODES.shell)
        output = self.sendCmd("rm -rf %s" % path)
        self.popMode()
        return output

    def put(self, *args, **kwargs):
        """Transfers a file from local machine to the server using :meth:`~.Node.scp`. An alias to :meth:`~.Node.copyFromLocal`"""
        self.copyFromLocal(*args, **kwargs)

    def get(self, *args, **kwargs):
        """Transfers a file from remote server to locaal machine using :meth:`~.Node.scp`. An alias to :meth:`~.Node.copyToLocal`"""
        self.copyToLocal(*args, **kwargs)

    def copyFromLocal(self, local_src, remote_dest):
        """Transfers a file from local machine to the server using :meth:`~.Node.scp`"""
        if not local_src.startswith("/"):
            # If this is not an absolute path, consider it present in potluck's "remote" directory
            for d in (ROOT_DIR, REMOTE_DIR):
                potential_src = os.path.join(d, local_src)
                if os.path.exists(potential_src):
                    local_src = potential_src
                    break
                else:
                    logger.warning("Path '%s' does not exist on local machine" % potential_src)
            else:
                logger.error("Path '%s' does not exist on local machine" % local_src)
                raise ValueError("Path '%s' does not exist on local machine" % local_src)

        # Create parent directory on the remote machine
        remote_parent_dir = os.path.dirname(remote_dest)
        self.createDirectory(remote_parent_dir)

        logger.info("Copying '%s' from local machine  to %s at '%s'" % (local_src, self.ip, remote_dest))
        return self.scp(local_src, "root@%s:%s" % (self.ip, remote_dest))

    def copyToLocal(self, remote_src, local_dest):
	print "in copytolocal func"
	print "remote_src is:" , remote_src
	print "local_dest is" , local_dest
        """Transfers a file from remote server to local machine using :meth:`~.Node.scp`"""
        if not local_dest.startswith("/"):
            local_dest = os.path.join(REMOTE_DIR, local_dest)
        logger.info("Copying '%s' from '%s' to local machine at '%s'" % (remote_src, self.ip, local_dest))
        parent_dir = os.path.dirname(local_dest)
	print "parent_dir is:",parent_dir
        if not os.path.exists(parent_dir):
            os.makedirs(parent_dir)
        return self.scp("root@%s:%s" % (self.ip, remote_src), local_dest)

    def scp(self, src, dst):
        """Transfers a file to the remote machine using scp

        .. note::

            This method is internally used by copyFromLocal and copyToLocal methods
        """
        scp_cmd = "scp -r %s %s" % (src, dst)
        connect_handle = pexpect.spawn(scp_cmd)
        connect_handle.setwinsize(400,400)
        connect_handle.logfile_read = sys.stdout
        i = 0
        ssh_newkey = r'(?i)Are you sure you want to continue connecting'
        while True:
            i = connect_handle.expect([ssh_newkey, 'assword: ', pexpect.EOF, pexpect.TIMEOUT])
            if i==0:
                connect_handle.sendline('yes')
                continue
            elif i==1:
                 #logger.info("Password supplied")
                 connect_handle.sendline(self.password)
                 continue
            elif i==2:
                logger.info("Scp complete")
                logger.info(connect_handle.before)
                break
            elif i==3:
                logger.warning("Timeout while waiting for connection")
                logger.info(connect_handle.before) # print out the result
                raise ValueError("Unable to establish connection")
        return True


    def getEpochTime(self, time_str=None):
        """Executes ``date +%s`` command on the node and gets the system time in epoch format

        :param time_str: Get time for this particular datetime string
        :returns: System time in epoch format
        :rtype: float
        """
        self.pushMode(CLI_MODES.shell)
        if time_str is None:
            system_time = self.sendCmd(r"date +%s")
        else:
            system_time = self.sendCmd("date -d '%s' " % time_str + r"+%s")

        try:
            system_time = float(system_time)
            logger.info("Time %f" % system_time)
        except:
            logger.error("Invalid system time '%s' on node '%s'" % (system_time, self))
            raise ValueError("Invalid system time '%s' on node '%s'" % (system_time, self))
        self.popMode()
        return system_time

    def getClusterRole(self):
        """Returns this node's role in TM Cluster

        :returns: Node role in upper-case
        """
	list = []
	counter = 0
	f = self.sendCmd("cat /etc/hadoop/conf/hdfs-site.xml")
	#print f
	list = f.split("\n")
	#print list
	for line in list:
		counter = counter + 1
		if "dfs.ha.namenodes" in line:
			logger.info("Setup is HA")
			logger.info ("Finding nameservices id")
			a = list[counter]
			print line
			print "a: " + a 
			nameservice1=a.split("value>")[1].split("<")[0].split(",")[0].strip()
			nameservice2=a.split("value>")[1].split("<")[0].split(",")[1].strip()
	output = self.sendCmd("hdfs haadmin -getServiceState " + nameservice1)
	#match = re.search(r"active \(running\)", output, re.I):
        match =  re.search(r"active", output, re.I)
        match1 =  re.search(r"standby", output, re.I)
	ROLE = "MASTER"
	if match:
            return ROLE
	elif match1:
	    ROLE = "STANDBY"
            return ROLE
	else:
            logger.error("Unable to get node role from `hdfs haadmin -getServiceState`")
            return None

    def checkserviceProcess(self, ipaddr, processname):
        logger.info("Monitoring of process %s" % processname)
        # Connect to the device and get a node object
        logger.info("Checking that %s process is running" % processname)
        self.setMode("shell")
        output = self.sendCmd("service " + processname + " status", ignoreErrors=True)
        #if not re.search(r"active \(running\)", output, re.I):
        if not re.search(r"running", output, re.I):
            return (0)
        else:
            return (1)

    def grepProcess(self, ipaddr, processname):
        logger.info("Monitoring of process %s" % processname)
        # Connect to the device and get a node object
        logger.info("Checking that %s process is running" % processname)
        self.setMode("shell")
        #output = self.run_cmd("ps -ef | grep  -i " + '"' + processname + '"')
        output = self.run_cmd("ps -ef | grep  -i " + '"' + processname + '"' + " | grep -v grep ")
        if len(re.findall(r"%s" % processname, output, re.IGNORECASE)) > 0:
            return (1)
        else:
            return (0)

    def redisProcess(self, ipaddr):
	print "ipaddr is :",ipaddr
        self.setMode("shell") 
        output = self.run_cmd("/opt/redis/src/redis-cli cluster nodes")
        if len(re.findall(r"disconnected", output, re.IGNORECASE)) > 0:
            return (0)
        else:
            return (1)
    def connectDb(self, ipaddr, dbdir):
        # Connect to the device and get a node object
        print "connection to device is successful"
        # logger.info("Checking that %s db is connecting" %dbname)
        self.setMode("shell")
        print "printing now..."
        output = self.run_cmd(dbdir + " shell", "0>")
        output = self.run_cmd("list", "0>")
        if re.search(r"hbase\(main\)", output, re.IGNORECASE):
            return (1)
        else:
            return (0)
    def connectDb1(self, ipaddr):
        self.setMode("shell")
        output = self.run_cmd("hive", ">")
        output = self.run_cmd("show databases;", ">")
        if re.search(r"hive", output, re.IGNORECASE):
            return (1)
        else:
            return (0)

    def verifyConfigs(self, ipaddrlist, fileName, nodetype):
        ip1 = ipaddrlist[0]
        ip2 = ipaddrlist[1]
        dest_dir = "/var/www/html/Potluck_cloudera/useroutput"
        for ip in ipaddrlist:
            ip = ip.strip("\n")
            self.connect(ip)
            self.setMode("shell")
            destfile = dest_dir + "_" + nodetype
            print "destfile is:", destfile
            self.copyToLocal(fileName, destfile)
            # node.copyToLocal(fileName,dest_dir)
        filename1 = dest_dir + ip1
        filename2 = dest_dir + ip2
        print "filename1 is", filename1
        print "filename2 is", filename1
        logger.info("Matching the configuration between master and standby node")
        diff = diffxml(filename1, filename2, ignorefile)
        f = open(diff, "r")
        if len(f.readlines()) > 0:
            return (0)
        else:
            return (1)
